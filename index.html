<html>
<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script type="text/javascript" src="d3/d3.js"></script>
  <style>
    h2 {
      color: black;
    }
    .grid line {
      stroke: lightgrey;
      stroke-dasharray: 3;
      stroke-opacity: 0.5;
      shape-rendering: crispEdges;
    }
    .grid path {
      stroke-width: 0;
    }
    button.buttons {
      text-align: center;
      font-size: small;
      background-color: lightgray;
      border: 1px solid black;
      padding: 3px;
      margin: 5px;
    }
    button.buttons:hover {
      background-color: darkgray;
      cursor: pointer;
    }
    div.button_container {
      align: center;
    }

  </style>
  </head>


<body>
  <h2>Parasite growth across a complex life cycles</h2>
  <div>More details about the database, as well as the data itself, can be found
     <a href='http://onlinelibrary.wiley.com/doi/10.1002/ecy.1680/full'
     target="_blank">here</a>
   </div>

  <script type="text/javascript">
    function draw(data) {
        "use strict";

        var margin = {top: 50, right: 30, bottom: 50, left: 70},
            chartwidth = 500,
            chartheight = 500,
            canvaswidth = chartwidth + margin.right + margin.left,
            canvasheight = chartheight + margin.top + margin.bottom;


        // create container for buttons
        var button_container = d3.select("body")
          .append("div")
          .attr('class', 'button_container')
          .style('width', canvaswidth + "px")

        // create buttons for interactivity
        var buttons = button_container.selectAll("button")
          .data(["Random species", "One host cycles", "Two host cycles", "Three host cycles", "Four plus host cycles",
                "To intermediate host", "To definitive host", "To facultative host", "To humans", "RESET"])
          .enter()
          .append('button')
          .attr('class', 'buttons')
          .attr('id', function(d) {
            return d.split(' ').join('_');
          })
          .text(function(d) {return d;})
          .style('width', chartwidth / 5 + "px")
          .style('float', 'left')



        // create svg as last element within body
        var svg = d3.select("body")
            .append("svg")
            .attr("width", canvaswidth)
            .attr("height", canvasheight);


        // create scales
        var xscale = d3.scalePoint()
          .domain(["propagule", "1st", "2nd", "3rd", "4th", "5th"])
          .range([margin.left, chartwidth]) // scale from margin to width
          .padding(0.2)
        var yscale = d3.scaleLog()
          .range([chartheight, margin.bottom]) // (inverse) scale from height (bottom) to upper marginn
          .domain(d3.extent(data, function(d) {
            return d['Biovolume']
          }));
        var colscale = d3.scaleOrdinal(d3.schemeCategory10);

        // define axes
        var xaxis = d3.axisBottom(xscale);
        var yaxis = d3.axisLeft(yscale);

        // add axes to the svg element
        svg.append('g') // add x-axis
          .attr('class', 'x axis')
          .attr('transform', "translate(0," + chartheight + ")")
          .call(xaxis);
        svg.append("text") // add title
          .attr('class', 'x title')
          .attr("text-anchor", "middle")
          .attr("transform", "translate("+ (chartwidth/2) + "," + (chartheight + (margin.bottom/1.5)) +")")  // centre below axis
          .text('Host in cycle');
        svg.append('g') // add y-axis
          .attr('class', 'y axis')
          .attr('transform', "translate(" + margin.left + ",0)")
          .call(yaxis.ticks(5));
        svg.append("g") // add y-grid
            .attr("class", "grid")
            .attr('transform', "translate(" + margin.left + ",0)")
            .call(yaxis.ticks(5)
                .tickSize(-chartwidth + margin.right)
                .tickFormat("")
            )
        svg.append('text') // add title
          .attr('class', 'y title')
          .attr("text-anchor", "middle")
          .attr("transform", "translate("+ (margin.left/3) +"," + (chartheight/2) + ") rotate(-90)")
          .text('Biovolume');


          /* first made paths for each species
          but to interactively highlight each connection (also within species)
          need to have each line independent (i.e. not a path). This loop
          restructures data as links between points, so as to make the lines
          */
          var links = []
          for(var i = 0; i < (data.length - 1); i += 1) {
            var sp1 = data[i]["Parasite.species"], // create variables for making new data
                sp2 = data[i + 1]["Parasite.species"],
                size1 = data[i]["Biovolume"],
                size2 = data[i + 1]["Biovolume"],
                hostn1 = data[i]["Host.no"],
                hostn2 = data[i + 1]["Host.no"];
            if( (sp1 == sp2) && ((hostn2 - hostn1) == 1)) { // create new data object
              var link_row = {
                Species: sp1,
                Host1: data[i]['Host.nofac'],
                Host2: data[i + 1]['Host.nofac'],
                Biov1: size1,
                Biov2: size2,
                maxLCL: data[i]['maxLCL'],
                to_int: data[i]['trans_to_int'],
                to_def: data[i]['trans_to_def'],
                to_fac: data[i]['trans_to_fac'],
                to_hum: data[i]['trans_to_human']
              };
            links.push(link_row); // add link data to a data array
            };
          };


        var plot_geoms = function() {
          // plot points
          svg.selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
            .attr("class", "species points")
            .attr("id", function(d) {
              return d['Parasite.species'].split(' ').join('_');
            })
            .attr('cx', function(d) {
              return xscale(d['Host.nofac']);
            })
            .attr('cy', function(d) {
              return yscale(d['Biovolume']); // need to filter out NaN values
            })
            .attr('r', 3)
            .attr('fill', function(d) {
              return colscale(d['maxLCL']);
            })
            .attr('opacity', 0.05);

          // add line segments connecting points for each species
          svg.selectAll('line')
            .data(links)
            .enter()
            .append('line')
            .attr("class", "species lines")
            .attr("id", function(d) {return d.Species.split(' ').join('_')})
            .attr("x1", function(d) {return xscale(d.Host1)})
            .attr("x2", function(d) {return xscale(d.Host2)})
            .attr("y1", function(d) {return yscale(d.Biov1)})
            .attr("y2", function(d) {return yscale(d.Biov2)})
            .attr("stroke", function(d) {return colscale(d.maxLCL)})
            .attr("stroke-width", 1)
            .attr("stroke-opacity", 0.1)
            .attr("fill", "none");

            d3.select('body')
              .append('div')
              .attr('class', 'explanation')
              .text("The life cycles of parasitic organisms can be convoluted and bizarre. Some worms infect up to five different hosts in succession before reproducing. Long, multi-host life cycles are a paradox. These parasites risk not being transmitted between their obligate hosts and thus dying before reproducing. Parasites with complex life cycles must also be able to deal with multiple host physiologies and immune systems. Nonetheless, complex life cycles are the norm among parasitic worms like tapeworms and roundworms. This interactive uses a life cycle database to examine how parasitic worms divide their growth among their multiple hosts.")
              .style('width', canvaswidth + "px");
          }
          plot_geoms()






        var update = function(data_var_points, data_grp_points, data_var_lines, data_grp_lines,
        grp_color, grp_opacity, grp_r, text_for_annotation, text_for_explanation) {
          /*
          function takes into conditions for highlighting points and lines
          cond_points and cond_lines should return true/false
          */

          // update points
          svg.selectAll("circle")
            .transition()
            .duration(1500)
            .attr('fill', function(d) {
              if(d[data_var_points] == data_grp_points) {
                return grp_color;
              } else {
                return 'gray';
              }
            })
            .attr('opacity', function(d) {
              if(d[data_var_points] == data_grp_points) {
                return grp_opacity;
              } else {
                return 0.05;
              }
            })
            .attr('r', function(d) {
              if(d[data_var_points] == data_grp_points) {
                return grp_r;
              } else {
                return 3
              }
            });

          // update lines
          svg.selectAll("line.species.lines")
            .transition()
            .duration(1500)
            .attr("stroke", function(d) {
              if(d[data_var_lines] == data_grp_lines) {
                return grp_color;
              } else {
                return 'gray'
              }
            })
            .attr("stroke-opacity", function(d) {
              if(d[data_var_lines] == data_grp_lines) {
                return grp_opacity;
              } else {
                return 0.05;
              }
            });

            // remove old annotation, add/update new one
            svg.select(".annotation") //remove old annotation, if any
              .remove();
            var annotation = svg.append("text") // (re)create a text element
              .attr('class', 'annotation')
              .attr("text-anchor", "middle")
              .attr("transform", "translate(" + xscale("3rd") + "," + yscale(1e-5) + ")");
            annotation.transition()
              .duration(1500)
              .text(text_for_annotation)
              .attr('fill', grp_color);

            // add an explanatory text below chart for each scenario
            d3.select(".explanation") //remove old annotation, if any
              .remove();
            d3.select('body')
              .append('div')
              .attr('class', 'explanation')
              .text(text_for_explanation)
              .style('width', canvaswidth + "px");
          }


        // make buttons functional
        d3.select("button#One_host_cycles")
          .on('click', function() {
            update('maxLCL', 1, 'maxLCL', 1, colscale(1), 0.5, 5,
            "Species with one host cycles",
            "Parasite species that infect just one host during their life cycle have simple life cycles. Their lone host is usually a vertebrate and they grow substantially in their lone host.")
          })

        d3.select("button#Two_host_cycles")
          .on('click', function() {
            update('maxLCL', 2, 'maxLCL', 2, colscale(2), 0.3, 5,
            "Species with two host cycles",
            "Parasite species that obligatorily infect multiple hosts have complex life cycles. The first host is called the intermediate host, and the second host is the definitive host. Reproduction occurs in the definitive host. Parasites with two-host cycles usually grow in both hosts, but particularly the definitive host.")
          })

        d3.select("button#Three_host_cycles")
          .on('click', function() {
            update('maxLCL', 3, 'maxLCL', 3, colscale(3), 0.5, 5,
            "Species with three host cycles",
            "Parasite species with three-host life cycles infect two intermediate hosts before reproducing in the third (definitive) host. Growth can occur at any stage, but it is common that little growth occurs in the second intermediate host.")
          })

        d3.select("button#Four_plus_host_cycles") // needs work!
          .on('click', function() {
            update('maxLCL', 4, 'maxLCL', 4, colscale(4), 1, 5,
            "Species with four host cycles",
            "Relatively few parasites have cycles longer than three hosts. Growth in the intermediate hosts is variable. Often, intermediate hosts in these long cycles are not obligatory, i.e. the parasite can complete the cycle with or without them.")
          })


        // make set of species for use with random species button
        var species = d3.set();
        data.forEach( function(d) {
          species.add(d['Parasite.species']);
        });

        d3.select("button#Random_species")
          .on('click', function() {
            var randsp = species.values()[
              Math.random() * species.values().length | 0
            ]
            var rsdata = data.filter(function(d)
             {return d['Parasite.species'] == randsp}); // subset data to rand species
            var rsannotation = randsp + ", " + rsdata[0]['maxLCL'] + " host cycle, " + rsdata[0]['complete_size']
            update('Parasite.species', randsp, 'Species', randsp, 'red', 1, 5,
            rsannotation,
            "")
          })



        d3.select("button#To_intermediate_host")
          .on('click', function() {
            update('Def.int', 'int', 'to_int', 'yes', colscale(5), 0.4, 5,
            "Growth in intermediate hosts",
            "Parasites use intermediate hosts for growth, development, and transportation. Growth in the first host appears common, whereas growth in latter hosts may or may not occur.")
          })
        d3.select("button#To_definitive_host")
          .on('click', function() {
            update('Def.int', 'def', 'to_def', 'yes', colscale(7), 0.3, 5,
            "Growth in definitive hosts",
            "Parasites reproduce in their definitive host. In many animals, larger size is associated with higher fecundity; bigger females make more eggs. Thus, it is not surprising that parasites usually grow significantly in their final host.")
          })
        d3.select("button#To_facultative_host", colscale(8), 1, 5)
          .on('click', function() {
            update('Facultative_bool', 'yes', 'to_fac', 'yes', colscale(9), 1, 5,
            "Growth in facultative hosts",
            "Most parasites have a fixed succession of hosts they have to infect to complete the life cycle. But some don't; they have flexible life cycles with facultative hosts that are not needed. Commonly, the hosts in the middle of cycle (2nd host) are facultative and growth is minimal in such hosts.")
          })
        d3.select("button#To_humans")
          .on('click', function() {
            update('human', 'yes', 'to_hum', 'yes', colscale(10), 1, 5,
            "Growth in humans",
            "We, as a species, also have our share of worms! Species that infect humans (we are usually definitive hosts) tend to do quite well (exhibit substantial growth).")
          })


        d3.select("button#RESET")
          .on('click', function() {
            plot_geoms()
          })


        } //end of draw function


  </script>

  <script type="text/javascript">
  /*
    Use D3 to load the data
    */

  d3.csv("data3.csv", function(d) { //d refers to row in csv file
    d['maxLCL'] = +d['maxLCL']; // 'unary' operator converts strings to number; Javscript trick
    d['Host.no'] = +d['Host.no'];
    d['Biovolume'] = +d['Biovolume'];
    if(!isNaN(d['Biovolume'])) {return d}; // remove all rows where biovolume couldn't be coerced to a number
  },
  draw);
  </script>
</body>
</html>
